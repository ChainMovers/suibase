---
title: Keypairs and Wallets
contributors: true
editLink: true
---

## Facts

::: tip Fact Sheet

- Sui keys, on disk for Sui binaries, are in file: `$HOME/sui_config/sui.keystore `
- Keys are persisted in the file as a JSON array
- Entries in the array are base64 encoded strings e.g.: `AIUPxQveY18QxhDDdTO0D0OD6PNV+et50068d1g/rIyl`
- When base64 decoded, the byte counts of key strings is 33
- The first byte of the decoded key indicates the key type followed by the 32 byte private key seed
- Key types:
  - 0 -> ed25519 keytype
  - 1 -> secp256k1 keytype
  - 2 -> secp256r1 keytype
- Public keys are generated from the private keys. The length of the public key in bytes:
  - 0 -> 32 bytes
  - 1 -> 33 bytes
  - 2 -> 33 bytes
- Sui addresses are hex strings 66 characters long with prefix '0x', e.g.: `0xa9e2db385f055cc0215a3cde268b76270535b9443807514f183be86926c219f4`
- Sui addresses are generated by hashing the key type and the public key bytes, converting to a hex string
  and prefixing with '0x'
- blake2b is used for hashing

:::

Suggested subjects:

- How to restore a Keypair from a secret
- How to verify a Keypair
- How to generate a vanity address
- How to import/export (explain sui.keystore hexa need 'sui keytool convert' for wallet import).

## How to generate a new Keypair

Different actions that you make with Sui libraries require a keypair. A keypair can be generated by using cryptographic algorithms such as: Ed25519, ECDSA Secp256k1 & ECDSA Secp256r1.

::: code-tabs

@tab:active CLI

```shell
To be done. Add your contribution here.
```

@tab Rust

```rust
To be done. Add your contribution here.
```

@tab Python

```python
from pysui.abstracts.client_keypair import SignatureScheme
from pysui.sui.sui_config import SuiConfig

# The method we want to use is on the SuiConfig object
config = SuiConfig.default_config()

# Create a new ed25519 keypair and writes to sui.keystore
# With no additional arguments, pysui generates a 24 work mnemonic phrase and
# default derivation path associated with the key SignatureScheme

# ed25519
ed_mnemonics, ed_address = config.create_new_keypair_and_address(SignatureScheme.ED25519)
print(f"ed25519 Address: {ed_address.address} phrase: {ed_mnemonics}")

# secp256k1
k1_mnemonics, k1_address = config.create_new_keypair_and_address(SignatureScheme.SECP256K1)
print(f"secp256k1 Address: {k1_address.address} phrase: {k1_mnemonics}")

# secp256r1
r1_mnemonics, r1_address = config.create_new_keypair_and_address(SignatureScheme.SECP256R1)
print(f"secp256r1 Address: {r1_address.address} phrase: {r1_mnemonics}")

```

@tab TypeScript

```ts
// Generate Ed25519 keypair
const keypair_ed25519 = new Ed25519Keypair();

// Generate Seco256k1 keypair
const keypair_secp256k1 = new Secp256k1Keypair();
```

:::

## How to restore a Keypair from a secret

If you already have your secret, you can get your Keypair and you can use it to perform different actions.

1. From Bytes
::: code-tabs

@tab:active CLI

```shell
To be done. Add your contribution here.
```

@tab Rust

```rust
To be done. Add your contribution here.
```

@tab Python

```python
To be done. Add your contribution here.
```

@tab TypeScript

```ts
const SECP256K1_SECRET_KEY = [
    59, 148, 11, 85, 134, 130, 61, 253, 2, 174, 59, 70, 27, 180, 51, 107, 94, 203,
    174, 253, 102, 39, 170, 146, 46, 252, 4, 143, 236, 12, 136, 28,
  ]
const secretKey = new Uint8Array(SECP256K1_SECRET_KEY);

const keypair = Secp256k1Keypair.fromSecretKey(secretKey)
```


```Rust
To be done. Add your contribution here.
```

:::

2. From Base64 String
::: code-tabs

@tab:active CLI

```shell
To be done. Add your contribution here.
```

@tab Rust

```rust
To be done. Add your contribution here.
```

@tab Python

```python
To be done. Add your contribution here.
```

@tab TypeScript

```ts
const ED25519_SECRET_KEY = 'mdqVWeFekT7pqy5T49+tV12jO0m+ESW7ki4zSU9JiCg='

const secretKey = fromB64(ED25519_SECRET_KEY)

const keypair = Ed25519Keypair.fromSecretKey(secretKey)
```


```Rust
To be done. Add your contribution here.
```

:::
