#!/bin/bash

# Do not call this script directly. It is a "common script" called by the other scripts.
#
# It initializes a bunch of environment variable, verify that some initialization took
# place, identify some common user errors etc...

# DTP does not work with version below these.
MIN_SUI_VERSION="sui 0.22.0"
MIN_RUST_VERSION="rustc 1.65.0"

# Mandatory command line input
SCRIPTS_DIR=$1
SCRIPT_NAME=$2
NETNAME=$3
SUI_REPO_BRANCH=$4

# Utility functions.
setup_error() { echo "$*" 1>&2 ; exit 1; }
export -f setup_error
version_greater_equal() { printf '%s\n%s\n' "$2" "$1" | sort --check=quiet --version-sort; }
export -f version_greater_equal
script_cmd() { script -efqa "$SCRIPT_OUTPUT" -c "$*"; }
export -f script_cmd
beginswith() { case $2 in "$1"*) true;; *) false;; esac; }
export -f beginswith

# Two very convenient variables for directories.
SUI_BASE_DIR="$(cd "$(dirname "$SCRIPTS_DIR")"; pwd)" # This does one-level above /scripts (absolute path).
WORKDIRS="$SUI_BASE_DIR/workdirs"

# Some other commonly used locations.
LOCAL_BIN="~/.local/bin"

SUI_REPO_DIR="$WORKDIRS/$NETNAME/sui-repo"
SUI_BIN_DIR="$SUI_REPO_DIR/target/debug"
GENESIS_DATA_DIR="$SCRIPTS_DIR/genesis_data"

CONFIG_DATA_DIR="$WORKDIRS/$NETNAME/config"
PUBLISHED_DATA_DIR="$CONFIG_DATA_DIR/published-data"

# Configuration files (often needed for sui CLI calls)
NETWORK_CONFIG="$CONFIG_DATA_DIR/network.yaml"
CLIENT_CONFIG="$CONFIG_DATA_DIR/client.yaml"


build_sui_repo_branch() {

  # Verify Sui pre-requisites are installed.
  which curl &> /dev/null || setup_error "Need to install curl. See https://docs.sui.io/build/install#prerequisites";
  which git &> /dev/null || setup_error "Need to install git. See https://docs.sui.io/build/install#prerequisites";
  which cmake &> /dev/null || setup_error "Need to install cmake. See https://docs.sui.io/build/install#prerequisites";
  which rustc &> /dev/null || setup_error "Need to install rust. See https://docs.sui.io/build/install#prerequisites";
  which cargo &> /dev/null || setup_error "Need to install cargo. See https://docs.sui.io/build/install#prerequisites";

  # Verify Rust is recent enough.
  version_greater_equal "$(rustc --version)" "$MIN_RUST_VERSION" || setup_error "Upgrade rust to a more recent version";

  # If not already done, get the github sui $SUI_REPO_BRANCH.
  if [ ! -d "$SUI_REPO_DIR" ]
  then
    git clone -b devnet https://github.com/MystenLabs/sui.git "$SUI_REPO_DIR"  || setup_error "Failed getting Sui $SUI_REPO_BRANCH branch from github";
  fi

  # Update sui devnet local repo (if needed)
  (cd "$SUI_REPO_DIR" && git remote update >& /dev/null)
  V1=$(cd "$SUI_REPO_DIR"; git rev-parse HEAD)
  V2=$(cd "$SUI_REPO_DIR"; git rev-parse '@{u}')
  if [ "$V1" != "$V2" ]
  then
    # Does a bit more than needed, but should allow to recover
    # from most operator error...
    echo Updating sui $NETNAME in sui-base...
    (cd "$SUI_REPO_DIR" && git switch $SUI_REPO_BRANCH > /dev/null)
    (cd "$SUI_REPO_DIR" && git fetch > /dev/null)
    (cd "$SUI_REPO_DIR" && git reset --hard origin/$SUI_REPO_BRANCH > /dev/null)
    (cd "$SUI_REPO_DIR" && git merge '@{u}')
  fi

  # Verify sui built is latest.
  echo Building $NETNAME using latest Sui $SUI_REPO_BRANCH branch...
  (cd "$SUI_REPO_DIR"; cargo build)

  # Sanity test that the sui binary works
  if [ ! -f "$SUI_BIN_DIR/sui" ]; then
    setup_error "$SUI_BIN_DIR/sui binary not found"
  fi

  update_SUI_VERSION_var;

  # Check if sui is recent enough.
  version_greater_equal "$SUI_VERSION" "$MIN_SUI_VERSION" || setup_error "Sui binary version too old (not supported)"
}

export -f build_sui_repo_branch

check_dev_setup() {
  # Sanity check the setup was completed successfully.
  #
  # This should be check for most scripts.
  #
  # This is to minimize support/confusion. First, get the initial setup right
  # before letting the user do more damage...
  if [ ! -d "$WORKDIRS" ]; then
    setup_error "$WORKDIRS missing. Please run '$NETNAME update' first"
  fi

  if [ ! -d "$SUI_REPO_DIR" ]; then
    setup_error "$SUI_REPO_DIR missing. Please run '$NETNAME update' first"
  fi

  if [ ! -d "$WORKDIRS/$NETNAME" ]; then
    setup_error "$WORKDIRS/$NETNAME missing. Please run '$NETNAME update' first"
  fi

  if [ ! -f "$NETWORK_CONFIG" ]; then
    setup_error "$NETWORK_CONFIG missing. Please run '$NETNAME update' first"
  fi

  if [ ! -f "$CLIENT_CONFIG" ]; then
    setup_error "$CLIENT_CONFIG missing. Please run '$NETNAME update' first"
  fi
}
export -f check_dev_setup


is_localnet_installed() {

  # Just check if present on the filesystem, not if running or executeable.
  # Detect if any problem. Return true only if installation is likely healthy.
  #
  # That one is different than check_dev_setup because we do not want to
  # report error, we just want to detect and fix automatically.
  if [ ! -d "$WORKDIRS" ]; then
    false; return;
  fi

  if [ ! -d "$WORKDIRS/$NETNAME" ]; then
    false; return;
  fi

  if [ ! -d "$SUI_REPO_DIR" ]; then
    false; return;
  fi

  if [ ! -d "$CONFIG_DATA_DIR" ]; then
    false; return;
  fi

  if [ ! -f "$NETWORK_CONFIG" ]; then
    false; return;
  fi

  if [ ! -f "$CLIENT_CONFIG" ]; then
    false; return;
  fi

  if [ ! -f "$SUI_BIN_DIR/sui" ]; then
    false; return;
  fi

  true; return;
}
export -f is_localnet_installed

common_create_workdirs() {
  mkdir -p "$WORKDIRS"
  mkdir -p "$WORKDIRS/$NETNAME"

  # Check if there is an active symlink, if not, create one.  
  # (Note: if the symlink is broken, do not attempt to fix it.
  #  The symlink represent the "user intent" and must be 
  #  preserved when it exists).
  if [ ! -L "$WORKDIRS/active" ]; then
     set_active_workdir;
  fi  
}
export -f common_create_workdirs

set_active_workdir() {
  # Create a symlink to the current $NETNAME if not already done.
  update_ACTIVE_WORKDIR_var;
  if [ ! -L "$WORKDIRS/active" ]; then
    ln -s "$WORKDIRS/$NETNAME" "$WORKDIRS/active"
  else 
    if [[ "$ACTIVE_WORKDIR" != "$NETNAME" ]]; then
      ln -sf "$WORKDIRS/$NETNAME" "$WORKDIRS/active"
    fi
  fi
}
export -f set_active_workdir

update_ACTIVE_WORKDIR_var() {
  # This is the active $NETNAME (deduced from the symlink).
  if [ ! -L $WORKDIRS/active ]; then
    unset ACTIVE_WORKDIR
  else
    RESOLVED_PATH="$(readlink -f $WORKDIRS/active)"
    ACTIVE_WORKDIR="$(basename $RESOLVED_PATH)"
  fi
}
export -f update_ACTIVE_WORKDIR_var

update_SUI_PROCESS_PID_var() {
  # Useful to check if the sui process is running (this is the parent for the "localnet")
  #
  # Details on the cryptic parsing:
  #   Get ps with "sui start" in its command line, grep exclude itself from the list, head takes the first process (should
  #   not be more than one) the 1st sed remove leading space, the 2nd sed split words into line and finally the pid is the
  #   word on the first/head line.
  #
  if [[ $(uname) == "Darwin" ]]; then
    SUI_PROCESS_PID=$(ps x -o pid,comm | grep "sui" | grep -v grep | head -n 1 | sed -e 's/^[[:space:]]*//' | sed 's/ /\n/g' | head -n 1)
  else
    SUI_PROCESS_PID=$(ps x -o pid,cmd | grep "sui start" | grep -v grep | head -n 1 | sed -e 's/^[[:space:]]*//' | sed 's/ /\n/g' | head -n 1)
  fi
}
export -f update_SUI_PROCESS_PID_var

update_SUI_VERSION_var() {
  # Take note that $SUI_BIN_DIR here is used to properly consider if the
  # context of the script is localnet, devnet, testnet, mainet... (they
  # are not the same binaries and versions).
  SUI_VERSION=$($SUI_BIN_DIR/sui --version)
  if [ -z "$SUI_VERSION" ]; then
    setup_error "$SUI_BIN_DIR/sui --version not running as expected"
  fi
}
export -f update_SUI_VERSION_var

stop_sui_process() {
  # success/failure is reflected by the SUI_PROCESS_PID var.
  # noop if the process is already stopped.
  update_SUI_PROCESS_PID_var;
  if [ ! -z "$SUI_PROCESS_PID" ]; then
    echo "Stopping $NETNAME (process pid $SUI_PROCESS_PID)"
    if [[ $(uname) == "Darwin" ]]; then
      kill -9 $SUI_PROCESS_PID
    else
      skill -9 $SUI_PROCESS_PID
    fi

    # Make sure it is dead.
    end=$((SECONDS+15))
    DEAD=false
    AT_LEAST_ONE_SECOND=false
    while [ $SECONDS -lt $end ]; do
      update_SUI_PROCESS_PID_var;
      if [ -z "$SUI_PROCESS_PID" ]; then
        break
      else
        echo -n "."
        sleep 1
        AT_LEAST_ONE_SECOND=true
      fi
    done

    # Just UI aesthetic newline for when there was "." printed.
    if [ "$AT_LEAST_ONE_SECOND" = true ]; then
      echo
    fi

    if [ ! -z "$SUI_PROCESS_PID" ]; then
      setup_error "Sui process pid=$SUI_PROCESS_PID still running. Try again, or stop (kill) the sui process yourself before proceeding."
    fi
  fi
}
export -f stop_sui_process

start_sui_process() {
  # success/failure is reflected by the SUI_PROCESS_PID var.
  # noop if the process is already started.

  # Detect an installation problem (took a while to debug when it did happen)
  if [ ! -f "$NETWORK_CONFIG" ]; then
    setup_error "$NETWORK_CONFIG missing. Please re-run '$NETNAME update' to fix."
  fi

  if [ ! -f "$CLIENT_CONFIG" ]; then
    setup_error "$CLIENT_CONFIG missing. Please re-run '$NETNAME update' to fix."
  fi

  update_SUI_PROCESS_PID_var;
  if [ -z "$SUI_PROCESS_PID" ]; then
    echo "Starting localnet process"
    $SUI_BIN_DIR/sui start --network.config "$NETWORK_CONFIG" >& "$CONFIG_DATA_DIR/sui-process.log" &
    NEW_SUI_PID=$!

    # Loop until "sui client" confirms to be working, or exit if that takes
    # more than 30 seconds.
    end=$((SECONDS+30))
    ALIVE=false
    AT_LEAST_ONE_SECOND=false
    while [ $SECONDS -lt $end ]; do
      CHECK_ALIVE=$($SUI_BIN_DIR/sui client --client.config "$CLIENT_CONFIG" objects | grep -i Digest)
      if [ ! -z "$CHECK_ALIVE" ]; then
        ALIVE=true
        break
      else
        echo -n "."
        sleep 1
        AT_LEAST_ONE_SECOND=true
      fi
    done

    # Just UI aesthetic newline for when there was "." printed.
    if [ "$AT_LEAST_ONE_SECOND" = true ]; then
      echo
    fi

    # Act on success/failure of the sui process responding to "sui client".
    if [ "$ALIVE" = false ]; then
      echo "Sui process not responding. Try again? (may be the host is too slow?)."
      exit;
    fi

    update_SUI_PROCESS_PID_var;
    echo "localnet started (process pid $SUI_PROCESS_PID)"
    update_SUI_VERSION_var;
    echo "$SUI_VERSION"
  fi
}
export -f start_sui_process

update_SUI_REPO_INFO_var() {
  SUI_REPO_INFO="github branch $(cd $SUI_REPO_DIR; git branch --show-current)"
}
export -f update_SUI_REPO_INFO_var

ensure_client_OK() {
  # This is just in case the user switch the envs on the clients instead of simply using
  # the scripts... we have then to fix things up here. Not an error unless the fix fails.

  # TODO Add paranoiac validation, fix the URL part, for now this is used only for localnet.

  # Make sure localnet exists in sui envs (ignore errors because likely already exists)
  $SUI_BIN_DIR/sui client --client.config "$CLIENT_CONFIG" new-env --alias $NETNAME --rpc http://0.0.0.0:9000 >& /dev/null

  # Make localnet the active envs (should already be done, just in case, do it again here).
  $SUI_BIN_DIR/sui client --client.config "$CLIENT_CONFIG" switch --env $NETNAME > /dev/null
}
export -f ensure_client_OK

publish_clear_output() {
  if [ -n "$MOVE_TOML_PACKAGE_NAME" ]; then
    rm -rf "$PUBLISH_DATA_DIR/$MOVE_TOML_PACKAGE_NAME/package_id.txt"
  fi
  # Following files created only on confirmed success of publication.
  #rm -rf "$PUBLISH_DATA_DIR/client_addresses.txt"
}
export -f publish_clear_output

# Check if there is a Move.toml at specified (parameter) directory.
#
# If not found, then look deeper at move/Move.toml.
#
# If not found, the variable is unset.
#
# When found, while at it, update also the following variable:
#   MOVE_TOML_PACKAGE_NAME
update_MOVE_TOML_DIR_var() {
  unset MOVE_TOML_DIR
  unset MOVE_TOML_PACKAGE_NAME

  if [ -f $1/Move.toml ]; then
    MOVE_TOML_DIR=$1
  else
    if [ -f $1/move/Move.toml ]; then
      MOVE_TOML_DIR=$1/move
    fi
  fi

  if [ -n "$MOVE_TOML_DIR" ]; then
    # Extract "name" key from toml, we can do something less hackish if ever worth it...
    # ... reality is the whole publish/upgrade process will likely change by mainnet.
    MOVE_TOML_PACKAGE_NAME=$(sed -n '/^name *=* */{s///;s/^"//;s/"$//;p;}' "$MOVE_TOML_DIR/Move.toml")
  fi
}
export -f update_MOVE_TOML_DIR_var

publish_localnet() {

  PASSTHRU_OPTIONS=$1

  ensure_client_OK;

  if [ -z "$MOVE_TOML_PACKAGE_NAME" ]; then
    echo "Package name could not be found"
    exit
  fi

  INSTALL_DIR="$PUBLISHED_DATA_DIR/$MOVE_TOML_PACKAGE_NAME"

  echo "Package name=[$MOVE_TOML_PACKAGE_NAME]"
  #echo "Build location=[$INSTALL_DIR]"
  mkdir -p "$INSTALL_DIR"

  # Set the output for the "script_cmd"
  SCRIPT_OUTPUT="$INSTALL_DIR/publish_output.txt"
  rm -rf $SCRIPT_OUTPUT

  # Run unit tests.
  #script_cmd "lsui move test --install-dir \"$INSTALL_DIR\" -p \"$MOVE_TOML_DIR\""

  # Build the Move package for publication.
  #echo Now publishing on network
  CMD="lsui client publish --gas-budget 30000 --install-dir \"$INSTALL_DIR\" \"$MOVE_TOML_DIR\" $PASSTHRU_OPTIONS"
  echo $CMD
  script_cmd $CMD

  # Grab the first line with an immutable "ID" after the "Created Objects" string.
  id_line=$(cat "$SCRIPT_OUTPUT" | sed '1,/Created Objects/d' | grep 'ID' | grep 'Immutable')

  if [ -z "$id_line" ]; then
    setup_error "Could not find the package id from $SCRIPT_OUTPUT"
  fi

  ID=""
  for i in $id_line
  do
    if beginswith 0x $i; then
      ID=$i
      break;
    fi
  done

  if [ -z "$ID" ]; then
    setup_error "Could not find Package id in $SCRIPT_OUTPUT"
  fi

  # Test the publication by retreiving object information from the network
  # using that parsed package id.
  script_cmd "lsui client object $ID"
  validation=$(lsui client object $ID | grep "Move Package")
  if [ -z "$validation" ]; then
    setup_error "Unexpected object type (Not a Move Package)"
  fi

  JSON_STR="[\"$ID\"]"
  echo $JSON_STR > "$INSTALL_DIR/package-id.json"
  echo
  echo "Package ID is $JSON_STR"
  echo "Also written in [$INSTALL_DIR/package-id.json]"
  echo Publication Successful
}
export -f publish_localnet

